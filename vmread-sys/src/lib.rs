#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* automatically generated by rust-bindgen */

pub type size_t = ::std::os::raw::c_ulong;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
pub type __ssize_t = ::std::os::raw::c_long;
pub type pid_t = __pid_t;
pub type ssize_t = __ssize_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ProcessData {
    pub mapsStart: u64,
    pub mapsSize: u64,
    pub pid: pid_t,
}
#[test]
fn bindgen_test_layout_ProcessData() {
    assert_eq!(
        ::std::mem::size_of::<ProcessData>(),
        24usize,
        concat!("Size of: ", stringify!(ProcessData))
    );
    assert_eq!(
        ::std::mem::align_of::<ProcessData>(),
        8usize,
        concat!("Alignment of ", stringify!(ProcessData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProcessData>())).mapsStart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProcessData),
            "::",
            stringify!(mapsStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProcessData>())).mapsSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ProcessData),
            "::",
            stringify!(mapsSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProcessData>())).pid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ProcessData),
            "::",
            stringify!(pid)
        )
    );
}
extern "C" {
    pub static mut vmread_dfile: *mut libc::FILE;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_FILE_HEADER {
    pub Machine: u16,
    pub NumberOfSections: u16,
    pub TimeDateStamp: u32,
    pub PointerToSymbolTable: u32,
    pub NumberOfSymbols: u32,
    pub SizeOfOptionalHeader: u16,
    pub Characteristics: u16,
}
#[test]
fn bindgen_test_layout__IMAGE_FILE_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_FILE_HEADER>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_FILE_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_FILE_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_FILE_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).Machine as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).NumberOfSections as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(NumberOfSections)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).TimeDateStamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).PointerToSymbolTable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(PointerToSymbolTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).NumberOfSymbols as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(NumberOfSymbols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).SizeOfOptionalHeader as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(SizeOfOptionalHeader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).Characteristics as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type IMAGE_FILE_HEADER = _IMAGE_FILE_HEADER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_DATA_DIRECTORY {
    pub VirtualAddress: u32,
    pub Size: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_DATA_DIRECTORY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DATA_DIRECTORY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_DATA_DIRECTORY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DATA_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DATA_DIRECTORY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DATA_DIRECTORY>())).VirtualAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DATA_DIRECTORY),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_DATA_DIRECTORY>())).Size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DATA_DIRECTORY),
            "::",
            stringify!(Size)
        )
    );
}
pub type IMAGE_DATA_DIRECTORY = _IMAGE_DATA_DIRECTORY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_OPTIONAL_HEADER64 {
    pub Magic: u16,
    pub MajorLinkerVersion: u8,
    pub MinorLinkerVersion: u8,
    pub SizeOfCode: u32,
    pub SizeOfInitializedData: u32,
    pub SizeOfUninitializedData: u32,
    pub AddressOfEntryPoint: u32,
    pub BaseOfCode: u32,
    pub ImageBase: u64,
    pub SectionAlignment: u32,
    pub FileAlignment: u32,
    pub MajorOperatingSystemVersion: u16,
    pub MinorOperatingSystemVersion: u16,
    pub MajorImageVersion: u16,
    pub MinorImageVersion: u16,
    pub MajorSubsystemVersion: u16,
    pub MinorSubsystemVersion: u16,
    pub Win32VersionValue: u32,
    pub SizeOfImage: u32,
    pub SizeOfHeaders: u32,
    pub CheckSum: u32,
    pub Subsystem: u16,
    pub DllCharacteristics: u16,
    pub SizeOfStackReserve: u64,
    pub SizeOfStackCommit: u64,
    pub SizeOfHeapReserve: u64,
    pub SizeOfHeapCommit: u64,
    pub LoaderFlags: u32,
    pub NumberOfRvaAndSizes: u32,
    pub DataDirectory: [IMAGE_DATA_DIRECTORY; 16usize],
}
#[test]
fn bindgen_test_layout__IMAGE_OPTIONAL_HEADER64() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_OPTIONAL_HEADER64>(),
        240usize,
        concat!("Size of: ", stringify!(_IMAGE_OPTIONAL_HEADER64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_OPTIONAL_HEADER64>(),
        8usize,
        concat!("Alignment of ", stringify!(_IMAGE_OPTIONAL_HEADER64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).Magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).MajorLinkerVersion as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MajorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).MinorLinkerVersion as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MinorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).SizeOfCode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).SizeOfInitializedData as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfInitializedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).SizeOfUninitializedData as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfUninitializedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).AddressOfEntryPoint as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(AddressOfEntryPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).BaseOfCode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(BaseOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).ImageBase as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).SectionAlignment as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SectionAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).FileAlignment as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(FileAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).MajorOperatingSystemVersion
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MajorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).MinorOperatingSystemVersion
                as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MinorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).MajorImageVersion as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MajorImageVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).MinorImageVersion as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MinorImageVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).MajorSubsystemVersion as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MajorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).MinorSubsystemVersion as *const _
                as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MinorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).Win32VersionValue as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(Win32VersionValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).SizeOfImage as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).SizeOfHeaders as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfHeaders)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).CheckSum as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).Subsystem as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(Subsystem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).DllCharacteristics as *const _
                as usize
        },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(DllCharacteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).SizeOfStackReserve as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfStackReserve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).SizeOfStackCommit as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfStackCommit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).SizeOfHeapReserve as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfHeapReserve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).SizeOfHeapCommit as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfHeapCommit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).LoaderFlags as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(LoaderFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).NumberOfRvaAndSizes as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(NumberOfRvaAndSizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER64>())).DataDirectory as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(DataDirectory)
        )
    );
}
pub type IMAGE_OPTIONAL_HEADER64 = _IMAGE_OPTIONAL_HEADER64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS64 {
    pub Signature: u32,
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_OPTIONAL_HEADER64,
}
#[test]
fn bindgen_test_layout__IMAGE_NT_HEADERS64() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_NT_HEADERS64>(),
        264usize,
        concat!("Size of: ", stringify!(_IMAGE_NT_HEADERS64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_NT_HEADERS64>(),
        8usize,
        concat!("Alignment of ", stringify!(_IMAGE_NT_HEADERS64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_NT_HEADERS64>())).Signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS64),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_NT_HEADERS64>())).FileHeader as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS64),
            "::",
            stringify!(FileHeader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_NT_HEADERS64>())).OptionalHeader as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS64),
            "::",
            stringify!(OptionalHeader)
        )
    );
}
pub type IMAGE_NT_HEADERS = _IMAGE_NT_HEADERS64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB {
    pub InheritedAddressSpace: u8,
    pub ReadImageFileExecOptions: u8,
    pub BeingFebugged: u8,
    pub BitField: u8,
    pub Padding0: [u8; 4usize],
    pub Mutant: u64,
    pub ImageBaseAddress: u64,
    pub Ldr: u64,
}
#[test]
fn bindgen_test_layout__PEB() {
    assert_eq!(
        ::std::mem::size_of::<_PEB>(),
        32usize,
        concat!("Size of: ", stringify!(_PEB))
    );
    assert_eq!(
        ::std::mem::align_of::<_PEB>(),
        8usize,
        concat!("Alignment of ", stringify!(_PEB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB>())).InheritedAddressSpace as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(InheritedAddressSpace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB>())).ReadImageFileExecOptions as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(ReadImageFileExecOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB>())).BeingFebugged as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(BeingFebugged)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB>())).BitField as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(BitField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB>())).Padding0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Padding0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB>())).Mutant as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Mutant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB>())).ImageBaseAddress as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(ImageBaseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB>())).Ldr as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Ldr))
    );
}
pub type PEB = _PEB;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PEB32 {
    pub InheritedAddressSpace: u8,
    pub ReadImageFileExecOptions: u8,
    pub BeingFebugged: u8,
    pub BitField: u8,
    pub Mutant: u32,
    pub ImageBaseAddress: u32,
    pub Ldr: u32,
}
#[test]
fn bindgen_test_layout__PEB32() {
    assert_eq!(
        ::std::mem::size_of::<_PEB32>(),
        16usize,
        concat!("Size of: ", stringify!(_PEB32))
    );
    assert_eq!(
        ::std::mem::align_of::<_PEB32>(),
        4usize,
        concat!("Alignment of ", stringify!(_PEB32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB32>())).InheritedAddressSpace as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(InheritedAddressSpace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB32>())).ReadImageFileExecOptions as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(ReadImageFileExecOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB32>())).BeingFebugged as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(BeingFebugged)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB32>())).BitField as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(BitField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB32>())).Mutant as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(Mutant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB32>())).ImageBaseAddress as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(ImageBaseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PEB32>())).Ldr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB32),
            "::",
            stringify!(Ldr)
        )
    );
}
pub type PEB32 = _PEB32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WinOffsets {
    pub apl: i64,
    pub session: i64,
    pub stackCount: i64,
    pub imageFileName: i64,
    pub dirBase: i64,
    pub peb: i64,
    pub peb32: i64,
    pub threadListHead: i64,
    pub threadListEntry: i64,
    pub teb: i64,
}
#[test]
fn bindgen_test_layout_WinOffsets() {
    assert_eq!(
        ::std::mem::size_of::<WinOffsets>(),
        80usize,
        concat!("Size of: ", stringify!(WinOffsets))
    );
    assert_eq!(
        ::std::mem::align_of::<WinOffsets>(),
        8usize,
        concat!("Alignment of ", stringify!(WinOffsets))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinOffsets>())).apl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WinOffsets),
            "::",
            stringify!(apl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinOffsets>())).session as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WinOffsets),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinOffsets>())).stackCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WinOffsets),
            "::",
            stringify!(stackCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinOffsets>())).imageFileName as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WinOffsets),
            "::",
            stringify!(imageFileName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinOffsets>())).dirBase as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WinOffsets),
            "::",
            stringify!(dirBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinOffsets>())).peb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WinOffsets),
            "::",
            stringify!(peb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinOffsets>())).peb32 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WinOffsets),
            "::",
            stringify!(peb32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinOffsets>())).threadListHead as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WinOffsets),
            "::",
            stringify!(threadListHead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinOffsets>())).threadListEntry as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WinOffsets),
            "::",
            stringify!(threadListEntry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinOffsets>())).teb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(WinOffsets),
            "::",
            stringify!(teb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WinProc {
    pub process: u64,
    pub physProcess: u64,
    pub dirBase: u64,
    pub pid: u64,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_WinProc() {
    assert_eq!(
        ::std::mem::size_of::<WinProc>(),
        40usize,
        concat!("Size of: ", stringify!(WinProc))
    );
    assert_eq!(
        ::std::mem::align_of::<WinProc>(),
        8usize,
        concat!("Alignment of ", stringify!(WinProc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinProc>())).process as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WinProc),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinProc>())).physProcess as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WinProc),
            "::",
            stringify!(physProcess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinProc>())).dirBase as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WinProc),
            "::",
            stringify!(dirBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinProc>())).pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WinProc),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinProc>())).name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WinProc),
            "::",
            stringify!(name)
        )
    );
}
impl Default for WinProc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WinProcList {
    pub list: *mut WinProc,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_WinProcList() {
    assert_eq!(
        ::std::mem::size_of::<WinProcList>(),
        16usize,
        concat!("Size of: ", stringify!(WinProcList))
    );
    assert_eq!(
        ::std::mem::align_of::<WinProcList>(),
        8usize,
        concat!("Alignment of ", stringify!(WinProcList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinProcList>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WinProcList),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinProcList>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WinProcList),
            "::",
            stringify!(size)
        )
    );
}
impl Default for WinProcList {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WinExport {
    pub name: *mut ::std::os::raw::c_char,
    pub address: u64,
}
#[test]
fn bindgen_test_layout_WinExport() {
    assert_eq!(
        ::std::mem::size_of::<WinExport>(),
        16usize,
        concat!("Size of: ", stringify!(WinExport))
    );
    assert_eq!(
        ::std::mem::align_of::<WinExport>(),
        8usize,
        concat!("Alignment of ", stringify!(WinExport))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinExport>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WinExport),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinExport>())).address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WinExport),
            "::",
            stringify!(address)
        )
    );
}
impl Default for WinExport {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WinExportList {
    pub list: *mut WinExport,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_WinExportList() {
    assert_eq!(
        ::std::mem::size_of::<WinExportList>(),
        16usize,
        concat!("Size of: ", stringify!(WinExportList))
    );
    assert_eq!(
        ::std::mem::align_of::<WinExportList>(),
        8usize,
        concat!("Alignment of ", stringify!(WinExportList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinExportList>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WinExportList),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinExportList>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WinExportList),
            "::",
            stringify!(size)
        )
    );
}
impl Default for WinExportList {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WinModule {
    pub baseAddress: u64,
    pub entryPoint: u64,
    pub sizeOfModule: u64,
    pub name: *mut ::std::os::raw::c_char,
    pub loadCount: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_WinModule() {
    assert_eq!(
        ::std::mem::size_of::<WinModule>(),
        40usize,
        concat!("Size of: ", stringify!(WinModule))
    );
    assert_eq!(
        ::std::mem::align_of::<WinModule>(),
        8usize,
        concat!("Alignment of ", stringify!(WinModule))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinModule>())).baseAddress as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WinModule),
            "::",
            stringify!(baseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinModule>())).entryPoint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WinModule),
            "::",
            stringify!(entryPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinModule>())).sizeOfModule as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WinModule),
            "::",
            stringify!(sizeOfModule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinModule>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WinModule),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinModule>())).loadCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WinModule),
            "::",
            stringify!(loadCount)
        )
    );
}
impl Default for WinModule {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WinModuleList {
    pub list: *mut WinModule,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_WinModuleList() {
    assert_eq!(
        ::std::mem::size_of::<WinModuleList>(),
        16usize,
        concat!("Size of: ", stringify!(WinModuleList))
    );
    assert_eq!(
        ::std::mem::align_of::<WinModuleList>(),
        8usize,
        concat!("Alignment of ", stringify!(WinModuleList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinModuleList>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WinModuleList),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinModuleList>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WinModuleList),
            "::",
            stringify!(size)
        )
    );
}
impl Default for WinModuleList {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WinCtx {
    pub process: ProcessData,
    pub offsets: WinOffsets,
    pub ntKernel: u64,
    pub ntVersion: u16,
    pub ntBuild: u32,
    pub ntExports: WinExportList,
    pub initialProcess: WinProc,
}
#[test]
fn bindgen_test_layout_WinCtx() {
    assert_eq!(
        ::std::mem::size_of::<WinCtx>(),
        176usize,
        concat!("Size of: ", stringify!(WinCtx))
    );
    assert_eq!(
        ::std::mem::align_of::<WinCtx>(),
        8usize,
        concat!("Alignment of ", stringify!(WinCtx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinCtx>())).process as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WinCtx),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinCtx>())).offsets as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WinCtx),
            "::",
            stringify!(offsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinCtx>())).ntKernel as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(WinCtx),
            "::",
            stringify!(ntKernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinCtx>())).ntVersion as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(WinCtx),
            "::",
            stringify!(ntVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinCtx>())).ntBuild as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(WinCtx),
            "::",
            stringify!(ntBuild)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinCtx>())).ntExports as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(WinCtx),
            "::",
            stringify!(ntExports)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WinCtx>())).initialProcess as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(WinCtx),
            "::",
            stringify!(initialProcess)
        )
    );
}
impl Default for WinCtx {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " @brief Initialize the vmread context"]
    #[doc = ""]
    #[doc = " @param ctx context to be initialized"]
    #[doc = " @param pid target process ID"]
    #[doc = ""]
    #[doc = " Initialize ctx by using pid. If pid is 0,"]
    #[doc = " the function tries to determine it automatically."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " 0 if initialization was successful;"]
    #[doc = " otherwise, the return value is an error value."]
    pub fn InitializeContext(ctx: *mut WinCtx, pid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Free the vmread context"]
    #[doc = ""]
    #[doc = " @param ctx context to free"]
    #[doc = ""]
    #[doc = " It frees all the data inside the ctx making it free to be disposed"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Always 0"]
    pub fn FreeContext(ctx: *mut WinCtx) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the NT header of a module"]
    #[doc = ""]
    #[doc = " @param ctx vmread context"]
    #[doc = " @param process target process"]
    #[doc = " @param address base address of the target module"]
    #[doc = " @param header buffer to read the header to"]
    #[doc = " @param is64Bit flag that returns if the module is 64-bit"]
    #[doc = ""]
    #[doc = " header has to be at least one page long, and @is64Bit can not be NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Pointer to the NT header, if it was found;"]
    #[doc = " otherwise @c NULL"]
    pub fn GetNTHeader(
        ctx: *const WinCtx,
        process: *const WinProc,
        address: u64,
        header: *mut u8,
        is64Bit: *mut u8,
    ) -> *mut IMAGE_NT_HEADERS;
}
extern "C" {
    #[doc = " @brief Parse module export table, writing them to the export list"]
    #[doc = ""]
    #[doc = " @param ctx vmread context"]
    #[doc = " @param process target process"]
    #[doc = " @param moduleBase base address of the module"]
    #[doc = " @param exports address to the export table (parsed from the header)"]
    #[doc = " @param outList the list that gets the data written to"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " 0 on success;"]
    #[doc = " Otherwise a positive error number indicating stage of the failure"]
    pub fn ParseExportTable(
        ctx: *const WinCtx,
        process: *const WinProc,
        moduleBase: u64,
        exports: *mut IMAGE_DATA_DIRECTORY,
        outList: *mut WinExportList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Generate a module export list"]
    #[doc = ""]
    #[doc = " @param ctx vmread context"]
    #[doc = " @param process target process"]
    #[doc = " @param moduleBase base address"]
    #[doc = " @param outList the output list"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " 0 on success;"]
    #[doc = " Otherwise either -1, or a positive number indicating stage of the failure"]
    pub fn GenerateExportList(
        ctx: *const WinCtx,
        process: *const WinProc,
        moduleBase: u64,
        outList: *mut WinExportList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Free the data inside the export list"]
    #[doc = ""]
    #[doc = " @param list list to be freed"]
    pub fn FreeExportList(list: WinExportList);
}
extern "C" {
    #[doc = " @brief Get the address of a module export"]
    #[doc = ""]
    #[doc = " @param ctx vmread context"]
    #[doc = " @param process target process"]
    #[doc = " @param module base address of the module"]
    #[doc = " @param procName target export name"]
    #[doc = ""]
    #[doc = " This function generates an export list and immediately frees it, so it is advised against using it extensively. See GetProcAddress."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Virtual address of the export, 0, if not found"]
    pub fn GetProcAddress(
        ctx: *const WinCtx,
        process: *const WinProc,
        module: u64,
        procName: *const ::std::os::raw::c_char,
    ) -> u64;
}
extern "C" {
    #[doc = " @brief Find the proc address inside a given export list"]
    #[doc = ""]
    #[doc = " @param exports the list to be searched"]
    #[doc = " @param procName target export name"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Virtual address of the export, 0, if not found"]
    pub fn FindProcAddress(exports: WinExportList, procName: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    #[doc = " @brief Generate the list of processes"]
    #[doc = ""]
    #[doc = " @param ctx vmread context"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " A structure representing the process list"]
    pub fn GenerateProcessList(ctx: *const WinCtx) -> WinProcList;
}
extern "C" {
    #[doc = " @brief Free the data inside a process list"]
    #[doc = ""]
    #[doc = " @param list the list to have its data freed"]
    pub fn FreeProcessList(list: WinProcList);
}
extern "C" {
    #[doc = " @brief Generate the module list of a process"]
    #[doc = ""]
    #[doc = " @param ctx vmread context"]
    #[doc = " @param process target process"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " A structure representing all modules loaded by the given process"]
    pub fn GenerateModuleList(ctx: *const WinCtx, process: *const WinProc) -> WinModuleList;
}
extern "C" {
    #[doc = " @brief GenerateKernelModuleList"]
    #[doc = ""]
    #[doc = " @param ctx vmread context"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " A structure representing all modules loaded by the kernel"]
    pub fn GenerateKernelModuleList(ctx: *const WinCtx) -> WinModuleList;
}
extern "C" {
    #[doc = " @brief Free a given module list"]
    #[doc = ""]
    #[doc = " @param list list to have its data freed in"]
    pub fn FreeModuleList(list: WinModuleList);
}
extern "C" {
    #[doc = " @brief Find the module by a given name"]
    #[doc = ""]
    #[doc = " @param list list to perform search in"]
    #[doc = " @param moduleName target module name"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " A pointer to the found module information, @c NULL if not found"]
    pub fn GetModuleInfo(
        list: WinModuleList,
        moduleName: *const ::std::os::raw::c_char,
    ) -> *const WinModule;
}
extern "C" {
    #[doc = " @brief Get the process environment block"]
    #[doc = ""]
    #[doc = " @param ctx vmread context"]
    #[doc = " @param process target process"]
    #[doc = ""]
    #[doc = " Note that there is no error checking in this function. Even though PEB should always exist,"]
    #[doc = " the returned data may be garbage"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " The environment block"]
    pub fn GetPeb(ctx: *const WinCtx, process: *const WinProc) -> PEB;
}
extern "C" {
    #[doc = " @brief Get the process environment block (32-bit version)"]
    #[doc = ""]
    #[doc = " @param ctx vmread context"]
    #[doc = " @param process target process"]
    #[doc = ""]
    #[doc = " Note that there is no error checking in this function. Even though PEB should always exist,"]
    #[doc = " the returned data may be garbage"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " The environment block"]
    pub fn GetPeb32(ctx: *const WinCtx, process: *const WinProc) -> PEB32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RWInfo {
    pub local: u64,
    pub remote: u64,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_RWInfo() {
    assert_eq!(
        ::std::mem::size_of::<RWInfo>(),
        24usize,
        concat!("Size of: ", stringify!(RWInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RWInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(RWInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RWInfo>())).local as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RWInfo),
            "::",
            stringify!(local)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RWInfo>())).remote as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RWInfo),
            "::",
            stringify!(remote)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RWInfo>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RWInfo),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tlb_t {
    pub tlbHits: size_t,
    pub tlbMisses: size_t,
}
#[test]
fn bindgen_test_layout_tlb_t() {
    assert_eq!(
        ::std::mem::size_of::<tlb_t>(),
        16usize,
        concat!("Size of: ", stringify!(tlb_t))
    );
    assert_eq!(
        ::std::mem::align_of::<tlb_t>(),
        8usize,
        concat!("Alignment of ", stringify!(tlb_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tlb_t>())).tlbHits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tlb_t),
            "::",
            stringify!(tlbHits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tlb_t>())).tlbMisses as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tlb_t),
            "::",
            stringify!(tlbMisses)
        )
    );
}
extern "C" {
    #[doc = " @brief Read a piece of data in physical VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param local local data address"]
    #[doc = " @param remote remote data address"]
    #[doc = " @param size size of data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Data moved on success;"]
    #[doc = " -1 otherwise"]
    pub fn MemRead(data: *const ProcessData, local: u64, remote: u64, size: size_t) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Write a piece of data in physical VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param local local data address"]
    #[doc = " @param remote remote data address"]
    #[doc = " @param size size of data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Data moved on success;"]
    #[doc = " -1 otherwise"]
    pub fn MemWrite(data: *const ProcessData, local: u64, remote: u64, size: size_t) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Read multiple pieces of data in physical VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param info list of information for RW operations"]
    #[doc = " @param num number of info atoms"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Data moved on success;"]
    #[doc = " -1 otherwise"]
    pub fn MemReadMul(data: *const ProcessData, info: *mut RWInfo, num: size_t) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Write multiple pieces of data in physical VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param info list of information for RW operations"]
    #[doc = " @param num number of info atoms"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Data moved on success;"]
    #[doc = " -1 otherwise"]
    pub fn MemWriteMul(data: *const ProcessData, info: *mut RWInfo, num: size_t) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Read a unsigned 64-bit integer in virtual VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param dirBase page table directory base of a process"]
    #[doc = " @param remote remote data address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Read value, undefined on failure"]
    pub fn VMemReadU64(data: *const ProcessData, dirBase: u64, remote: u64) -> u64;
}
extern "C" {
    #[doc = " @brief Write a unsigned 64-bit integer in virtual VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param dirBase page table directory base of a process"]
    #[doc = " @param remote remote data address"]
    #[doc = " @param value value to be written"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " 8 on success;"]
    #[doc = " -1 on failure"]
    pub fn VMemWriteU64(data: *const ProcessData, dirBase: u64, remote: u64, value: u64)
        -> ssize_t;
}
extern "C" {
    #[doc = " @brief Read a unsigned 64-bit integer in physical VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param remote remote data address"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Read value, undefined on failure"]
    pub fn MemReadU64(data: *const ProcessData, remote: u64) -> u64;
}
extern "C" {
    #[doc = " @brief Write a unsigned 64-bit integer in physical VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param remote remote data address"]
    #[doc = " @param value value to be written"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " 8 on success;"]
    #[doc = " -1 on failure"]
    pub fn MemWriteU64(data: *const ProcessData, remote: u64, value: u64) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Read data in virtual VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param dirBase page table directory base of a process"]
    #[doc = " @param local local data address"]
    #[doc = " @param remote remote data address"]
    #[doc = " @param size size of data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Data moved on success;"]
    #[doc = " -1 otherwise"]
    pub fn VMemRead(
        data: *const ProcessData,
        dirBase: u64,
        local: u64,
        remote: u64,
        size: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Write data in virtual addresss space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param dirBase page table directory base of a process"]
    #[doc = " @param local local data address"]
    #[doc = " @param remote remote data address"]
    #[doc = " @param size size of data"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Data moved on success;"]
    #[doc = " -1 otherwise"]
    pub fn VMemWrite(
        data: *const ProcessData,
        dirBase: u64,
        local: u64,
        remote: u64,
        size: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Read multiple pieces of data in virtual VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param dirBase page table directory base of a process"]
    #[doc = " @param info list of information for RW operations"]
    #[doc = " @param num number of info atoms"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Data moved on success;"]
    #[doc = " -1 otherwise"]
    pub fn VMemReadMul(
        data: *const ProcessData,
        dirBase: u64,
        info: *mut RWInfo,
        num: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Write multiple pieces of data in virtual VM address space"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param dirBase page table directory base of a process"]
    #[doc = " @param info list of information for RW operations"]
    #[doc = " @param num number of info atoms"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Data moved on success;"]
    #[doc = " -1 otherwise"]
    pub fn VMemWriteMul(
        data: *const ProcessData,
        dirBase: u64,
        info: *mut RWInfo,
        num: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Translate a virtual VM address into a physical one"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param dirBase page table directory base of a process"]
    #[doc = " @param address virtual address to translate"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Translated linear address;"]
    #[doc = " 0 otherwise"]
    pub fn VTranslate(data: *const ProcessData, dirBase: u64, address: u64) -> u64;
}
extern "C" {
    #[doc = " @brief Set translation cache validity time in msecs"]
    #[doc = ""]
    #[doc = " @param newTime new validity length for a cache entry"]
    #[doc = ""]
    #[doc = " Defines for how long translation caches (TLB and page buffer) should be valid. Higher values lead to higher"]
    #[doc = " performance, but could potentially lead to incorrect translation if the page tables update in that period."]
    #[doc = " Especially dangerous if write operations are to be performed."]
    pub fn SetMemCacheTime(newTime: size_t);
}
extern "C" {
    #[doc = " @brief Get the default cache validity"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " Default cache validity time"]
    pub fn GetDefaultMemCacheTime() -> size_t;
}
extern "C" {
    #[doc = " @brief Retrieve current thread's TLB"]
    #[doc = ""]
    #[doc = " Memory TLB utilizes thread local storage to make the code concurrant. However, it might be beneficial to"]
    #[doc = " access the TLB structure to verify its entries asynchronously during idle. This allows to access the"]
    #[doc = " said TLB to do just that."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = " TLB of the running thread"]
    pub fn GetTlb() -> *mut tlb_t;
}
extern "C" {
    #[doc = " @brief Verify the TLB entries"]
    #[doc = ""]
    #[doc = " @param data VM process data"]
    #[doc = " @param tlb TLB structure to verify"]
    #[doc = " @param splitCount how many splits there are"]
    #[doc = " @param splitID which slice to verify"]
    #[doc = ""]
    #[doc = " This allows to verify the TLB structure before initializing a round of memory operations. Useful when the"]
    #[doc = " same memory addresses are being accessed in a loop with some delay. During the said delay we could verify"]
    #[doc = " the TLB structure in (optionally) multithreaded way to make the memory operations fast."]
    #[doc = ""]
    #[doc = " splitCount allows us to split the TLB entries to verify to separate threads. Passing 1 to splitCount makes"]
    #[doc = " the function verify the entirety of TLB (single-threaded scenario)"]
    pub fn VerifyTlb(
        data: *const ProcessData,
        tlb: *mut tlb_t,
        splitCount: size_t,
        splitID: size_t,
    );
}
extern "C" {
    #[doc = " @brief Flush all TLB entries"]
    #[doc = ""]
    #[doc = " @param tlb TLB structure to flush"]
    #[doc = ""]
    pub fn FlushTlb(tlb: *mut tlb_t);
}

unsafe impl Send for WinCtx {}
unsafe impl Sync for WinCtx {}
unsafe impl Send for WinProc {}
unsafe impl Sync for WinProc {}
unsafe impl Send for WinModule {}
unsafe impl Sync for WinModule {}
